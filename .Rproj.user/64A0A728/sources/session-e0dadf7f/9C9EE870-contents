---
title: "Taller Análisis Exploratorio Estadístico del ICFES"
author: "Jonatan Camilo Igua Contreras  \nID: 808919 | NRC: 73466\n"
date: "2025-04-0"
output:
  pdf_document: default
  word_document: default
subtitle: Minería de Datos
fontsize: 12pt
geometry: a4paper
---
## Análisis Exploratorio resultados de la prueba saber 11 
En el siguiente taller se realizo un análisis estadístico completo de los resultados del 
ICFES 2012.  

## 1. Carga y exploración de los datos

**Codificación dataset de ICFES**:
Para poder importar los datos del dataset del ICFES primero se tiene que mirar que tipo de codificación tiene el archivo .csv para saber como importarlo. Para esto se usa la funcion guess_encoding() del paquete readr, permite detectar la codificación de caracteres de un archivo CSV.
```{r codificacion_datos, warning=FALSE,message=FALSE}
library(knitr)
library(dplyr)
library(readr)
guess_encoding("SB11-20121-RGSTRO-CLFCCN-V1-0-txt-csv.csv") %>%
  kable(col.names = c("Codificación", "Confianza"), caption = "Codificaciones detectadas por `guess_encoding`")
```
Como se puede apreciar se obtuvo las codificaciones sugeridas, la confidence indica la confianza del tipo de codificación en este caso el valor es 1.00 el cual es la máxima confianza, por ende el archivo se debe leer con la codificación UTF-8

**Importar dataset de ICFES**:
Para importar los datos del archivo csv al proyecto de R se uso read_csv del paquete readr, para leer los datos y convertirlos en un data frame, se declaro que el tipo de codificación de los caracteres es UTF-8.
```{r datos_icfes, warning=FALSE}
library(readr)
datos_icfes <- read_csv("SB11-20121-RGSTRO-CLFCCN-V1-0-txt-csv.csv", locale = locale(encoding = "UTF-8"), show_col_types = FALSE)
```
Despues de visualizar los pimeros datos importados en R se obtuvo un error Delimiter: "," indicando que si bien los datos se importaron bien algunos caracteres se importaron un un formato erroneo por ese motivo se creo una segunda variable con el delimitador sep y se elimino el error.Para los analisis se tomo datos_icfes_delimiter para evitar errores con los datos.

```{r datos_icfesdelimiter, warning=FALSE}
datos_icfes_delimiter <- read.csv("SB11-20121-RGSTRO-CLFCCN-V1-0-txt-csv.csv", sep = "," , encoding = "UTF-8")

```

**¿Cuantas observaciones y variables hay?**
Para poder ver el numero de observaciones las filas de los datos se usa la función nrow().
```{r nobservaciones,warning=FALSE,message=FALSE,echo=FALSE}
# Cantidad de filas en el dataframe
n_filas <- nrow(datos_icfes_delimiter)

# Crear un dataframe 
data_frame(filas = n_filas) %>%
  kable(col.names = c("Número de filas"), caption = "Cantidad total de filas en el dataset")

```
Para poder ver el numero de variables las columnas se usa la función ncol().
```{r nvariables,warning=FALSE,message=FALSE,echo=FALSE}
# Cantidad de columnas en el dataframe
n_columnas <- ncol(datos_icfes_delimiter)

# Crear un dataframe 
data_frame(columnas = n_columnas) %>%
  kable(col.names = c("Número de columnas"), caption = "Cantidad total de columnas en el dataset")
```

**¿Que tipo de variables predominan: Numéricas o categóricas?** 
Para poder determinar que tipos de variables predominan en el conjunto de datos de las notas del ICFES, se uso la función str() para poder ver la estructura del data frame, esto permite ver el tipo de cada variable y su contenido. Se uso Kable para poder organizar los datos en formato de tabla.

```{r usoStr}
#Primeros 20 elementos de los datos
estructura <- capture.output(str(datos_icfes_delimiter[ , 1:20])) 
#Se guarda en la variable
estructura_df <- data.frame(estructura)

# Mostrar los datos
estructura_df %>%
  kable(col.names = c("Estructura de Datos"), caption = "Estructura del Dataset (primeras 20 columnas)")

```
Utilizando la funcion str() sin limitar la cantidad de datos a mostrar seobtuvieron 45390 filas y 112 columnas .

**Ver nombres y tipo de datos de las variables**
Con la funcion sapply podemos visualizar el nombre de las variables y su tipo de dato, se crea una tabla con dos columnas una con los nombres de las variables y otra con su tipo de dato.
```{r columnasNombre}
library(knitr)

tabla_tipos <- tibble::tibble(
  Variable = names(datos_icfes_delimiter),
  Tipo = sapply(datos_icfes_delimiter, class)
)

kable(tabla_tipos, caption = "Tipos de Variables en el DataFrame")
```
**Análisis de las variables del dataset de ICFES Saber 11**
Los tipos de datos encontrados en el dataset de las notas del ICFES son: 

*Character:* Es el tipo de dato usado para texto o cadenas de caracteres.

*Integer:* Se usa para los números enteros sin decimales.

*numeric:* Se usa para los números decimales se puede usan para números enteros también.

*logical:* Se usa para valores booleanos TRUE o FALSE.

Los variables del conjunto de datos son sobre datos del estudiante, residencia del estudiante, información sobre el colegio, información sobre los grados cursados, información familiar e ingresos.

**Cantidad de cada tipo de variable**
Para poder contar cada tipo de variable se uso la función sapply() la cual aplica una función a cada columna del data frame, se le aplico la función class para que tome el tipo de datos de cada variable, lo que genera es un vector con los datos, con la función table() se cuenta cuantas veces aparece un valor del vector creado con sapply().
```{r contar_variables}
tabla_tipos <- table(sapply(datos_icfes_delimiter, class))
tabla_tipos
```
Los datos obtenidos son con el dataset original, sin haberle hecho ninguna técnica de transformación y limpieza de datos, por ende se van a tomar como datos cualitativos el tipo character y como datos cuantitativos los tipos: integer y numeric.
Con este análisis en hay en total 47 variables categóricas o cualitativas y 64 variables cuantitativas o numéricas.
Pero en el conjunto hay una variable con un tipo de dato logical.
```{r logical}
variables_logicas <- names(datos_icfes_delimiter)[sapply(datos_icfes_delimiter, is.logical)]
variables_logicas
```
La variable contiene los siguientes datos:
```{r logical_data}
unique(datos_icfes_delimiter$ESTU_LIMITA_BAJAVISION)
all(is.na(datos_icfes_delimiter$ESTU_LIMITA_BAJAVISION))

```
Con la función unique permite ver cuantos valores distintos hay el resultado fue NA osea esta variable no contiene datos y se uso all para verificar si en toda la variable soy hay datos NA y arrojo TRUE quiere decir que esta variable este campo nunca tuvo datos. 

**Conclusión ¿Que tipo de variables predominan?**
Después de conocer y analizar cada variable se puede concluir que hay mas variables de tipo numéricas con 63 variables y 47 de tipo categóricas por ahora se toman como categóricas, la variable logical se descarta ya que al no contar con información no es importante en este análisis de tipo de variables.

## 2. Limpieza y preparación de datos

**Verificar valores faltantes**
En el anterior análisis se descubrió que la variable ESTU_LIMITA_BAJAVISION tiene valores faltantes, si se usa la función any con is.na se debe obtener un valor True.
```{r datos_faltantes}
any(is.na(datos_icfes_delimiter))
```
Para contar cuantos Na hay en todo el conjunto de datos se usa la función sum().
```{r datos_faltantesSUM}
sum(is.na(datos_icfes_delimiter))
```
Se encontro un valor considerable de valores NA

**Variables con valores NA** 
Para ver los valores faltantes por columna se usa colSums() para poder ver de manera sencilla la cantidad de valores NA de cada variable.
```{r datos_faltantesDimension}
#Por columna
na_por_columna <- colSums(is.na(datos_icfes_delimiter))

# columnas con NA
na_filtrados <- na_por_columna[na_por_columna > 0]

# Convertir a data frame 
naKable_df <- data.frame(
  Variable = names(na_filtrados),
  Cantidad_NA = as.numeric(na_filtrados)
)

#tabla
knitr::kable(naKable_df, caption = "Cantidad de valores faltantes (NA) por columna", align = "lc")
```
**Análisis de variables irrelevantes o vacías**
Después de mirar que variables contienen valores de tipo Na se analizo un conjunto de variables que para los siguientes análisis del taller no afectan a los resultados del análisis, estas variables son:
Las variables de reprobación de grados: Se eliminan porque es una variable que no es relevante para los próximos análisis.
Variables a eliminar: ESTU_REPROBO_CUARTO, ESTU_REPROBO_DECIMO,
ESTU_REPROBO_NOVENO,ESTU_REPROBO_OCTAVO,ESTU_REPROBO_PRIMERO,ESTU_REPROBO_QUINTO,ESTU_REPROBO_SEGUNDO,ESTU_REPROBO_SEPTIMO,ESTU_REPROBO_SEXTO,ESTU_REPROBO_TERCERO,ESTU_REPROBO_ONCE_MAS
Se crea una nueva variable llamada datos_icfes_reprobo que guardara los datos sin tener en cuenta los que se van a descartar para los análisis.
```{r eliminacion_reprobados,warning=FALSE,message=FALSE}
library(dplyr)

datos_icfes_reprobo <- datos_icfes_delimiter %>% select(-c(
  ESTU_REPROBO_CUARTO,
    ESTU_REPROBO_DECIMO,
    ESTU_REPROBO_NOVENO,
    ESTU_REPROBO_OCTAVO,
    ESTU_REPROBO_PRIMERO,
    ESTU_REPROBO_QUINTO,
    ESTU_REPROBO_SEGUNDO,
    ESTU_REPROBO_SEPTIMO,
    ESTU_REPROBO_SEXTO,
    ESTU_REPROBO_TERCERO,
    ESTU_REPROBO_ONCE_MAS
))

```
Variables de Incapacidad: En el conjunto de datos se elimino la variable ESTU_LIMITA_BAJAVISION ya que no es relevante para el análisis del taller se eliminara de la variable datos_icfes_reprobo

```{r eliminacion_incapacidad,warning=FALSE,message=FALSE}
datos_icfes_incapa <- datos_icfes_reprobo %>% select(-c(
  ESTU_LIMITA_BAJAVISION))

```
**Valores inconsistentes o faltantes** 

*ESTU_CUANTOS_COLE_ESTUDIO:* Se analizo si hay datos inconsistentes en la cantidad de colegios de un estudiante se valida que si un estudiante tiene registrado mas de 10 colegios ya es un dato dudoso.Se encontraron ceros inconsistencias.
```{r cantidad_colegios,warning=FALSE,message=FALSE}
library(dplyr)

datos_icfes_incapa %>%
  filter(ESTU_CUANTOS_COLE_ESTUDIO > 10) %>%
  select(ESTU_CUANTOS_COLE_ESTUDIO) %>%
  distinct() %>%
  arrange(desc(ESTU_CUANTOS_COLE_ESTUDIO))
```
*FAMI_PERSONAS_HOGAR* = Se analiza esta variable en donde si hay 0 personas del hogar o mas de 20 seria un dato inconsistente.Se encontraron ceros inconsistencias.
```{r cantidad_familia,warning=FALSE,message=FALSE}
datos_icfes_incapa %>%
  filter(FAMI_PERSONAS_HOGAR == 0 | FAMI_PERSONAS_HOGAR > 20) %>%
  select(FAMI_PERSONAS_HOGAR) %>%
  distinct() %>%
  arrange(FAMI_PERSONAS_HOGAR)
```

*FAMI_ESTRATO_VIVIENDA: * A la hora de analizar el estrado se encontraron inconsistencias con los datos ya que se encontraron estratos mayores del estrato 6
```{r estratos,warning=FALSE,message=FALSE}
library(dplyr)
library(knitr)

# Tabla de frecuencias del estrato de vivienda (incluye NA)
datos_icfes_incapa %>%
  group_by(FAMI_ESTRATO_VIVIENDA) %>%
  summarise(Frecuencia = n()) %>%
  arrange(desc(Frecuencia)) %>%
  kable(caption = "Distribución de la variable FAMI_ESTRATO_VIVIENDA")
```

Como solución se decidió por filtrar y limpiar los valores mayores del estrato 6.
```{r limpi_estrato,warning=FALSE,message=FALSE}

#  Nuevo dataset, dejando solo estratos válidos
datos_icfes_estrato <- datos_icfes_incapa %>%
  mutate(FAMI_ESTRATO_VIVIENDA = as.character(FAMI_ESTRATO_VIVIENDA)) %>%
  filter(FAMI_ESTRATO_VIVIENDA %in% c("1", "2", "3", "4", "5", "6") | is.na(FAMI_ESTRATO_VIVIENDA)) %>%
  mutate(FAMI_ESTRATO_VIVIENDA = as.numeric(FAMI_ESTRATO_VIVIENDA))

#Ver los estratos 
library(dplyr)
library(knitr)

datos_icfes_estrato %>%
  group_by(FAMI_ESTRATO_VIVIENDA) %>%
  summarise(Frecuencia = n()) %>%
  arrange(desc(Frecuencia)) %>%
  kable(caption = "Distribución nueva de la variable FAMI_ESTRATO_VIVIENDA")

```
**Estandarizar columnas con errores estructurales**

**Imputar datos faltantes** 


## 2.1 Nuevas transformaciones
**Calcular edad estudiante**

**Nueva columna edad categorizada**




## 3. Analisis Exploratorio y Univariado


