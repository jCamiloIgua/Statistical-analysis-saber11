---
title: "Taller Análisis Exploratorio Estadístico del ICFES"
author: "Jonatan Camilo Igua Contreras  \nID: 808919 | NRC: 73466\n"
date: "2025-04-0"
output:
  pdf_document: default
  word_document: default
subtitle: Minería de Datos
fontsize: 12pt
geometry: a4paper
---
## Análisis Exploratorio resultados de la prueba saber 11 
En el siguiente taller se realizo un análisis estadístico completo de los resultados del 
ICFES 2012.  

## 1. Carga y exploración de los datos

**Codificación dataset de ICFES**:
Para poder importar los datos del dataset del ICFES primero se tiene que mirar que tipo de codificación tiene el archivo .csv para saber como importarlo. Para esto se usa la funcion guess_encoding() del paquete readr, permite detectar la codificación de caracteres de un archivo CSV.
```{r codificacion_datos, warning=FALSE,message=FALSE}
library(knitr)
library(dplyr)
library(readr)
guess_encoding("SB11-20121-RGSTRO-CLFCCN-V1-0-txt-csv.csv") %>%
  kable(col.names = c("Codificación", "Confianza"), caption = "Codificaciones detectadas por `guess_encoding`")
```
Como se puede apreciar se obtuvo las codificaciones sugeridas, la confidence indica la confianza del tipo de codificación en este caso el valor es 1.00 el cual es la máxima confianza, por ende el archivo se debe leer con la codificación UTF-8

**Importar dataset de ICFES**:
Para importar los datos del archivo csv al proyecto de R se uso read_csv del paquete readr, para leer los datos y convertirlos en un data frame, se declaro que el tipo de codificación de los caracteres es UTF-8.
```{r datos_icfes, warning=FALSE}
library(readr)
datos_icfes <- read_csv("SB11-20121-RGSTRO-CLFCCN-V1-0-txt-csv.csv", locale = locale(encoding = "UTF-8"), show_col_types = FALSE)
```
Despues de visualizar los pimeros datos importados en R se obtuvo un error Delimiter: "," indicando que si bien los datos se importaron bien algunos caracteres se importaron un un formato erroneo por ese motivo se creo una segunda variable con el delimitador sep y se elimino el error.Para los analisis se tomo datos_icfes_delimiter para evitar errores con los datos.

```{r datos_icfesdelimiter, warning=FALSE}
datos_icfes_delimiter <- read.csv("SB11-20121-RGSTRO-CLFCCN-V1-0-txt-csv.csv", sep = "," , encoding = "UTF-8")

```

**¿Cuantas observaciones y variables hay?**
Para poder ver el numero de observaciones las filas de los datos se usa la función nrow().
```{r nobservaciones,warning=FALSE,message=FALSE,echo=FALSE}
# Cantidad de filas en el dataframe
n_filas <- nrow(datos_icfes_delimiter)

# Crear un dataframe 
data_frame(filas = n_filas) %>%
  kable(col.names = c("Número de filas"), caption = "Cantidad total de filas en el dataset")

```
Para poder ver el numero de variables las columnas se usa la función ncol().
```{r nvariables,warning=FALSE,message=FALSE,echo=FALSE}
# Cantidad de columnas en el dataframe
n_columnas <- ncol(datos_icfes_delimiter)

# Crear un dataframe 
data_frame(columnas = n_columnas) %>%
  kable(col.names = c("Número de columnas"), caption = "Cantidad total de columnas en el dataset")
```

**¿Que tipo de variables predominan: Numéricas o categóricas?** 
Para poder determinar que tipos de variables predominan en el conjunto de datos de las notas del ICFES, se uso la función str() para poder ver la estructura del data frame, esto permite ver el tipo de cada variable y su contenido. Se uso Kable para poder organizar los datos en formato de tabla.

```{r usoStr}
#Primeros 20 elementos de los datos
estructura <- capture.output(str(datos_icfes_delimiter[ , 1:20])) 
#Se guarda en la variable
estructura_df <- data.frame(estructura)

# Mostrar los datos
estructura_df %>%
  kable(col.names = c("Estructura de Datos"), caption = "Estructura del Dataset (primeras 20 columnas)")

```
Utilizando la funcion str() sin limitar la cantidad de datos a mostrar seobtuvieron 45390 filas y 112 columnas .

**Ver nombres y tipo de datos de las variables**
Con la funcion sapply podemos visualizar el nombre de las variables y su tipo de dato, se crea una tabla con dos columnas una con los nombres de las variables y otra con su tipo de dato.
```{r columnasNombre}
library(knitr)

tabla_tipos <- tibble::tibble(
  Variable = names(datos_icfes_delimiter),
  Tipo = sapply(datos_icfes_delimiter, class)
)

kable(tabla_tipos, caption = "Tipos de Variables en el DataFrame")
```
**Análisis de las variables del dataset de ICFES Saber 11**
Los tipos de datos encontrados en el dataset de las notas del ICFES son: 

*Character:* Es el tipo de dato usado para texto o cadenas de caracteres.

*Integer:* Se usa para los números enteros sin decimales.

*numeric:* Se usa para los números decimales se puede usan para números enteros también.

*logical:* Se usa para valores booleanos TRUE o FALSE.

Los variables del conjunto de datos son sobre datos del estudiante, residencia del estudiante, información sobre el colegio, información sobre los grados cursados, información familiar e ingresos.

**Cantidad de cada tipo de variable**
Para poder contar cada tipo de variable se uso la función sapply() la cual aplica una función a cada columna del data frame, se le aplico la función class para que tome el tipo de datos de cada variable, lo que genera es un vector con los datos, con la función table() se cuenta cuantas veces aparece un valor del vector creado con sapply().
```{r contar_variables}
tabla_tipos <- table(sapply(datos_icfes_delimiter, class))
tabla_tipos
```
Los datos obtenidos son con el dataset original, sin haberle hecho ninguna técnica de transformación y limpieza de datos, por ende se van a tomar como datos cualitativos el tipo character y como datos cuantitativos los tipos: integer y numeric.
Con este análisis en hay en total 47 variables categóricas o cualitativas y 64 variables cuantitativas o numéricas.
Pero en el conjunto hay una variable con un tipo de dato logical.
```{r logical}
variables_logicas <- names(datos_icfes_delimiter)[sapply(datos_icfes_delimiter, is.logical)]
variables_logicas
```
La variable contiene los siguientes datos:
```{r logical_data}
unique(datos_icfes_delimiter$ESTU_LIMITA_BAJAVISION)
all(is.na(datos_icfes_delimiter$ESTU_LIMITA_BAJAVISION))

```
Con la función unique permite ver cuantos valores distintos hay el resultado fue NA osea esta variable no contiene datos y se uso all para verificar si en toda la variable soy hay datos NA y arrojo TRUE quiere decir que esta variable este campo nunca tuvo datos. 

**Conclusión ¿Que tipo de variables predominan?**
Después de conocer y analizar cada variable se puede concluir que hay mas variables de tipo numéricas con 63 variables y 47 de tipo categóricas por ahora se toman como categóricas, la variable logical se descarta ya que al no contar con información no es importante en este análisis de tipo de variables.

## 2. Limpieza y preparación de datos

**Verificar valores faltantes**
En el anterior análisis se descubrió que la variable ESTU_LIMITA_BAJAVISION tiene valores faltantes, si se usa la función any con is.na se debe obtener un valor True.
```{r datos_faltantes}
any(is.na(datos_icfes_delimiter))
```
Para contar cuantos Na hay en todo el conjunto de datos se usa la función sum().
```{r datos_faltantesSUM}
sum(is.na(datos_icfes_delimiter))
```
Se encontro un valor considerable de valores NA

**Variables con valores NA** 
Para ver los valores faltantes por columna se usa colSums() para poder ver de manera sencilla la cantidad de valores NA de cada variable.
```{r datos_faltantesDimension}
#Por columna
na_por_columna <- colSums(is.na(datos_icfes_delimiter))

# columnas con NA
na_filtrados <- na_por_columna[na_por_columna > 0]

# Convertir a data frame 
naKable_df <- data.frame(
  Variable = names(na_filtrados),
  Cantidad_NA = as.numeric(na_filtrados)
)

#tabla
knitr::kable(naKable_df, caption = "Cantidad de valores faltantes (NA) por columna", align = "lc")
```
**Análisis de variables irrelevantes o vacías**
Después de mirar que variables contienen valores de tipo Na se analizo un conjunto de variables que para los siguientes análisis del taller no afectan a los resultados del análisis, estas variables son:
Las variables de reprobación de grados: Se eliminan porque es una variable que no es relevante para los próximos análisis.
Variables a eliminar: ESTU_REPROBO_CUARTO, ESTU_REPROBO_DECIMO,
ESTU_REPROBO_NOVENO,ESTU_REPROBO_OCTAVO,ESTU_REPROBO_PRIMERO,ESTU_REPROBO_QUINTO,ESTU_REPROBO_SEGUNDO,ESTU_REPROBO_SEPTIMO,ESTU_REPROBO_SEXTO,ESTU_REPROBO_TERCERO,ESTU_REPROBO_ONCE_MAS
Se crea una nueva variable llamada datos_icfes_reprobo que guardara los datos sin tener en cuenta los que se van a descartar para los análisis.
```{r eliminacion_reprobados,warning=FALSE,message=FALSE}
library(dplyr)

datos_icfes_reprobo <- datos_icfes_delimiter %>% select(-c(
  ESTU_REPROBO_CUARTO,
    ESTU_REPROBO_DECIMO,
    ESTU_REPROBO_NOVENO,
    ESTU_REPROBO_OCTAVO,
    ESTU_REPROBO_PRIMERO,
    ESTU_REPROBO_QUINTO,
    ESTU_REPROBO_SEGUNDO,
    ESTU_REPROBO_SEPTIMO,
    ESTU_REPROBO_SEXTO,
    ESTU_REPROBO_TERCERO,
    ESTU_REPROBO_ONCE_MAS
))

```
Variables de Incapacidad: En el conjunto de datos se elimino la variable ESTU_LIMITA_BAJAVISION ya que no es relevante para el análisis del taller se eliminara de la variable datos_icfes_reprobo

```{r eliminacion_incapacidad,warning=FALSE,message=FALSE}
datos_icfes_incapa <- datos_icfes_reprobo %>% select(-c(
  ESTU_LIMITA_BAJAVISION))

```
**Valores inconsistentes o faltantes** 

*ESTU_CUANTOS_COLE_ESTUDIO:* Se analizo si hay datos inconsistentes en la cantidad de colegios de un estudiante se valida que si un estudiante tiene registrado mas de 10 colegios ya es un dato dudoso.Se encontraron ceros inconsistencias.
```{r cantidad_colegios,warning=FALSE,message=FALSE}
library(dplyr)

datos_icfes_incapa %>%
  filter(ESTU_CUANTOS_COLE_ESTUDIO > 10) %>%
  select(ESTU_CUANTOS_COLE_ESTUDIO) %>%
  distinct() %>%
  arrange(desc(ESTU_CUANTOS_COLE_ESTUDIO))
```
*FAMI_PERSONAS_HOGAR* = Se analiza esta variable en donde si hay 0 personas del hogar o mas de 20 seria un dato inconsistente.Se encontraron ceros inconsistencias.
```{r cantidad_familia,warning=FALSE,message=FALSE}
datos_icfes_incapa %>%
  filter(FAMI_PERSONAS_HOGAR == 0 | FAMI_PERSONAS_HOGAR > 20) %>%
  select(FAMI_PERSONAS_HOGAR) %>%
  distinct() %>%
  arrange(FAMI_PERSONAS_HOGAR)
```

*FAMI_ESTRATO_VIVIENDA: * A la hora de analizar el estrado se encontraron inconsistencias con los datos ya que se encontraron estratos mayores del estrato 6
```{r estratos,warning=FALSE,message=FALSE}
library(dplyr)
library(knitr)

# Tabla de frecuencias del estrato de vivienda (incluye NA)
datos_icfes_incapa %>%
  group_by(FAMI_ESTRATO_VIVIENDA) %>%
  summarise(Frecuencia = n()) %>%
  arrange(desc(Frecuencia)) %>%
  kable(caption = "Distribución de la variable FAMI_ESTRATO_VIVIENDA")
```

Como solución se decidió por filtrar y limpiar los valores mayores del estrato 6.
```{r limpi_estrato,warning=FALSE,message=FALSE}

#  Nuevo dataset, dejando solo estratos válidos
datos_icfes_estrato <- datos_icfes_incapa %>%
  mutate(FAMI_ESTRATO_VIVIENDA = as.character(FAMI_ESTRATO_VIVIENDA)) %>%
  filter(FAMI_ESTRATO_VIVIENDA %in% c("1", "2", "3", "4", "5", "6") | is.na(FAMI_ESTRATO_VIVIENDA)) %>%
  mutate(FAMI_ESTRATO_VIVIENDA = as.numeric(FAMI_ESTRATO_VIVIENDA))

#Ver los estratos 
library(dplyr)
library(knitr)

datos_icfes_estrato %>%
  group_by(FAMI_ESTRATO_VIVIENDA) %>%
  summarise(Frecuencia = n()) %>%
  arrange(desc(Frecuencia)) %>%
  kable(caption = "Distribución nueva de la variable FAMI_ESTRATO_VIVIENDA")

```
**Estandarizar columnas con errores estructurales**

Se estandarizo los datos de los documentos de los estudiantes, ya que los valores que contiene esta variable son:
```{r documentoE,warning=FALSE,message=FALSE, echo=FALSE}

unique(datos_icfes_estrato$ESTU_TIPO_DOCUMENTO)

```
Para mejorar los datos se crea un vector con los nombres completos de los documentos y se usa dlpyr::recode para remplazar los valores.
```{r limpiezaDocum,warning=FALSE,message=FALSE}
library(dplyr)

datos_icfes_limpios <- datos_icfes_estrato %>%
  mutate(ESTU_TIPO_DOCUMENTO = case_when(
    ESTU_TIPO_DOCUMENTO == "C" ~ "Cédula",
    ESTU_TIPO_DOCUMENTO == "P" ~ "Pasaporte",
    ESTU_TIPO_DOCUMENTO == "T" ~ "Tarjeta de Identidad",
    ESTU_TIPO_DOCUMENTO == "R" ~ "Registro Civil",
    ESTU_TIPO_DOCUMENTO == "E" ~ "Cédula de Extranjería",
    ESTU_TIPO_DOCUMENTO == "Q" ~ "Permiso Especial de Permanencia",
    ESTU_TIPO_DOCUMENTO == "V" ~ "Visa",
    ESTU_TIPO_DOCUMENTO == ""  ~ "Sin Información",
    TRUE ~ ESTU_TIPO_DOCUMENTO  # para conservar cualquier valor inesperado
  ))

unique(datos_icfes_limpios$ESTU_TIPO_DOCUMENTO)

```
**Imputar datos faltantes** 
Primera se usa la funcion colSums con is.na para ver las columnas que contiene valores NA del dataset limpiado.
```{r Na_limpio,warning=FALSE,message=FALSE}
library(knitr)
library(dplyr)

colSums(is.na(datos_icfes_limpios)) %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "Variable") %>%
  rename(Valores_Faltantes = ".") %>%
  filter(Valores_Faltantes > 0) %>%
  kable(caption = "Cantidad de valores faltantes por variable")

```
Con las variables con datos NA, se procedera a escogar algunas varibles para realizar la imputacion de datos, la cual consiste en llenar los valores faltantes (NA) usando una tecnica logica en este caso usando la media, moda o diferentes tecnicas.
Las variables que cuenten con una valor elevado de NA no seran imputadas por su dificultad, como lo son: Estu_ETNIA, ESTU_CARRDESEADA_TIPO, ESTU_IES-COD-DESEADA etc
Por otro lado hay variables como lo son: FAMI_OCUPA_PADRE, FAMI_OCUPA_MADRE, ESTU_TRABAJA, FAMI_CELULAR y FAMI_NEVERA que tienen pocos valores NA, se pueden imputar
**Imputación Variables**
Para las varaibles de tipo Integer como FAMI_OCUPA_PADRE se realiza la imputacion con la mediana la cual remplaza los valors de NA por la media de los valores existentes, no se eliminan solo se remplazan.
```{r imputacion,warning=FALSE,message=FALSE}

#Copia del dataframe
datos_icfes_limpios2 <- datos_icfes_limpios
#FAMI_OCUPA_PADRE con la mediana
datos_icfes_limpios2 $FAMI_OCUPA_PADRE[is.na(datos_icfes_limpios2$FAMI_OCUPA_PADRE)] <- 
  median(datos_icfes_limpios2$FAMI_OCUPA_PADRE, na.rm = TRUE)

#La imputación se realizó correctamente
cat("Variable FAMI_OCUPA_PADRE imputada con mediana:\n")
summary(datos_icfes_limpios2$FAMI_OCUPA_PADRE)

#FAMI_OCUPA_MADRE
datos_icfes_limpios2$FAMI_OCUPA_MADRE[is.na(datos_icfes_limpios2$FAMI_OCUPA_MADRE)] <- 
  median(datos_icfes_limpios2$FAMI_OCUPA_MADRE, na.rm = TRUE)

cat("Variable FAMI_OCUPA_MADRE imputada con mediana:\n")
summary(datos_icfes_limpios2$FAMI_OCUPA_MADRE)

#ESTU_TRABAJA integer
datos_icfes_limpios2$ESTU_TRABAJA[is.na(datos_icfes_limpios2$ESTU_TRABAJA)] <- 
  median(datos_icfes_limpios2$ESTU_TRABAJA, na.rm = TRUE)

# La imputación se realizó correctamente
cat("Variable ESTU_TRABAJA imputada con mediana:\n")
summary(datos_icfes_limpios2$ESTU_TRABAJA)
#FAMI_CELULAR integer

datos_icfes_limpios2$FAMI_CELULAR[is.na(datos_icfes_limpios2$FAMI_CELULAR)] <- 
  median(datos_icfes_limpios2$FAMI_CELULAR, na.rm = TRUE)

# La imputación se realizó correctamente
cat("Variable FAMI_CELULAR imputada con mediana:\n")
summary(datos_icfes_limpios2$FAMI_CELULAR)

#FAMI_NEVERA integer

datos_icfes_limpios2$FAMI_NEVERA[is.na(datos_icfes_limpios2$FAMI_NEVERA)] <- 
  median(datos_icfes_limpios2$FAMI_NEVERA, na.rm = TRUE)

# La imputación se realizó correctamente
cat("Variable FAMI_NEVERA imputada con mediana:\n")
summary(datos_icfes_limpios2$FAMI_NEVERA)

```

Las variables seleccionadas se imputaron correctamente por esta razon si se mira el data frame datos_icfes_limpios2 estas no aparecen cuando se filtra por valores NA

```{r Na_limpio2,warning=FALSE,message=FALSE}
library(knitr)
library(dplyr)

colSums(is.na(datos_icfes_limpios2)) %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "Variable") %>%
  rename(Valores_Faltantes = ".") %>%
  filter(Valores_Faltantes > 0) %>%
  kable(caption = "Cantidad de valores faltantes por variable Imputado")

```
## 2.1 Nuevas transformaciones
**Calcular edad estudiante**
Para poder calcular edad del estudiante apartir de su fecha de nacimiento y la fecha del examen que es del 2012 se usan las variables: ESTU_NACIMIENTO_DIA, ESTU_NACIMIENTO_MES, ESTU_NACIMIENTO_ANNO.

Se creo una nueva columna con la fecha completa del estudiante llamada FECHA_NACIMIENTO

```{r N_edad,warning=FALSE,message=FALSE}
#Nueva columna con fecha completa
datos_icfes_limpios2$FECHA_NACIMIENTO <- as.Date(paste(datos_icfes_limpios2$ESTU_NACIMIENTO_ANNO,datos_icfes_limpios2$ESTU_NACIMIENTO_MES,datos_icfes_limpios2$ESTU_NACIMIENTO_DIA,sep = "-"),format = "%Y-%m-%d")

#Se toma una fecha del año 2012 ya que no esta la fecha exacta en los datos
fecha_examen <- as.Date("2012-01-01")

# Calcular la edad se restan la fecha de nacimiento de la fecha del examen
datos_icfes_limpios2$EDAD <- as.numeric(difftime(fecha_examen, datos_icfes_limpios2$FECHA_NACIMIENTO, units = "weeks")) / 52.25
# Redondear las edades a enteros
datos_icfes_limpios2$EDAD <- round(datos_icfes_limpios2$EDAD)
library(knitr)

# Mostrar solo las primeras 15 filas con la columna "EDAD"
kable(head(datos_icfes_limpios2 %>% select(EDAD), 15), 
      col.names = c("Edad"), 
      caption = "Primeras 15 Edades")

```

**Nueva columna edad categorizada**
Se creo una nueva columna llamada CATEGORIA_EDAD, para guardar las categorias de las edades, se uso la funcion mutate(), para poder agregar los valores en las columnas, y con el case_when() se crean las categorias de la edad.

```{r categoria_edad,warning=FALSE,message=FALSE}
# Crear la nueva columna "CATEGORIA_EDAD"
datos_icfes_limpios2 <- datos_icfes_limpios2 %>%
  mutate(CATEGORIA_EDAD = case_when(
    EDAD >= 12 & EDAD <= 17 ~ "Adolescente",
    EDAD >= 18 & EDAD <= 26 ~ "Joven",
    EDAD >= 27 & EDAD <= 59 ~ "Adulto",
    EDAD >= 60 ~ "Adulto mayor",
    TRUE ~ "Desconocido"  # Para edades fuera de los rangos
  ))

library(knitr)

kable(head(datos_icfes_limpios2 %>% select(EDAD, CATEGORIA_EDAD), 15), 
      col.names = c("Edad", "Categoría de Edad"), 
      caption = "Primeras 15 Edades y Categorías de Edad")


```


## 3. Analisis Exploratorio y Univariado


## 4. Análisis Bivariado

**¿Quien se destaca más en matemáticas hombres o mujeres?**


**¿Existe diferencia significativa en el puntaje global por género?**


**¿Qué tan fuerte es la relación entre matemáticas y lectura crítica?**

## 5. Visualización socioeconómica

